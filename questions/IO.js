questionSets.io = [
    {
        q: "Inżynieria ponowna to",
        a: [
            "proces transformacji istniejącego oprogramowania w celu poprawy jego pielęgnowalności",
            "zabieg służący do optymalizacji kodu oprogramowania",
            "implementacja dokumentacji technicznej aktualnie istniejącego oprogramowania",
            "proces wdrożeniowy oprogramowania na platformę docelową",
    ]},
    {
        q: "Produkty oprogramowania w inżynierii oprogramowania można podzielić na",
        a: [
            "odpowiedzi \"powszechne\" i \"dostosowane\" są poprawne",
            "dokumentacyjne - będące schematem programu",
            "powszechne – sprzedawane na wolnym rynku",
            "dostosowane – wykonywane na zamówienie"
    ]},
    {
        q: "W procesie wytwarzania oprogramowania nigdy nie występuje etap",
        a: [
            "fizycznego konstruowania oprogramowania",
            "specyfikacja – określenie i ustalenie wymagań, które musi spełniać oprogramowanie",
            "projektowanie – ustalenie ogólnej architektury systemu, wymagań dla poszczególnych jego składowych",
            "implementacja – realizacja ustalonej architektury poprzez implementację składowych (modułów) i połączeń między nimi"
    ]},
    {
        q: "Zdolność do pielęgnacji jest cechą oprogramowania oznaczającą",
        a: [
            "zdolność do ewolucji zgodnie z potrzebami klientów (rozbudowa programu)",
            "czystość kodu źródłowego",
            "zawartość pełnej dokumentacji technicznej kodu",
            "optymalizację działania programu"
    ]},
    {
        q: "Niezawodność jest cechą oprogramowania oznaczającą",
        a: [
            "nie powinno powodować fizycznych lub ekonomicznych katastrof w przypadku awarii",
            "w miarę możliwości najkrótszy okres bezczynności po awarii",
            "najmniejszą złożoność systemu oprogramowania",
            "stabilność systemu przy skomplikowanych operacjach"
    ]},
    {
        q: "Efektywność to cecha oprogramowania oznaczająca",
        a: [
            "nie marnuje zasobów systemowych",
            "program działa szybko, nie patrząc na ilość zużytej pamięci operacyjnej",
            "program długo się ładuje ale nie zużywa wiele zasobów systemowych",
            "nie ważne ile zajmuje miejsca operacyjnego na dysku twardym"
    ]},
    {
        q: "Inżynieria oprogramowania to",
        a: [
            "dziedzina inżynierii która obejmuje wszystkie aspekty tworzenia oprogramowania od fazy początkowej do jego pielęgnacji",
            "dziedzina informatyki odpowiadająca za przygotowanie projektu oprogramowania",
            "dziedzina inżynierii dotycząca optymalizacji kodu źródłowego",
            "dziedzina inżynierii obejmująca aspekty optymalizacji oprogramowania oraz jego pielęgnacji"
    ]},
    {
        q: "Proces tworzenia oprogramowania to",
        a: [
            "zbiór czynności i związanych z nim wyników, które zmierzają do opracowania produktu programowego",
            "jedna z pięciu faz opracowania finalnego programu",
            "żadna z odpowiedzi nie jest prawidłowa",
            "etap polegający na przygotowaniu projektu oprogramowania, w raz z dokumentacja techniczną"
    ]},
    {
        q: "Czynności wspólne dla wszystkich procesów inżynierii oprogramowania",
        a: [
            "specyfikacja, tworzenie, zatwierdzanie oraz ewolucja oprogramowania",
            "budowanie prototypu, zatwierdzanie i specyfikacja oprogramowania",
            "żadna odpowiedź nie jest prawdziwa",
            "testowanie, implementacja, ewolucja oprogramowania"
    ]},
    {
        q: "Model procesu tworzenia oprogramowania to",
        a: [
            "uproszczona prezentacja procesu tworzenia oprogramowania",
            "opis architektury systemu",
            "tworzenie dokumentacji z projektu oprogramowania",
            "opracowanie dokumentacji wymagań systemowych"
    ]},
    {
        q: "Przykłady modeli tworzenia oprogramowania to",
        a: [
            "model kaskadowy, model spiralny, model iteracyjny",
            "model oparty na prototypie, model wzrostowy, model kaskadowy",
            "model kołowy, model spiralny, model iteracyjny",
            "montaż z gotowych elementów, model kołowy, model oparty na prototypie"
    ]},
    {
        q: "Wadą modelu kaskadowego jest",
        a: [
            "wysokie koszty błędów we wstępnych fazach",
            "brak możliwość wykorzystania różnych technologii (metodyk strukturalnych i obiektowych)",
            "nie sprawdził się w wielu rzeczywistych projektach",
            "nie ma ścisłej kolejności wykonywania prac"
    ]},
    {
        q: "Wadą modelu opartego na prototypowaniu jest",
        a: [
            "konieczność oczekiwania na końcowy system po akceptacji prototypu",
            "prototyp nie pozwala rozpocząć szkolenie obsługi systemu po stronie klienta",
            "nie można w szybki sposób nanieść poprawki w modelu",
            "brak możliwości szybkiej demonstracji działającej wersji systemu"
    ]},
    {
        q: "Zaletą modelu opartego na prototypowaniu jest",
        a: [
            "lepsze określenie wymagań klienta",
            "brak kosztów budowy prototypu",
            "klient otrzymuje gotowy projekt",
            "duża dbałość o jakość i dostosowanie do środowiska docelowego już na etapie prototypu"
    ]},
    {
        q: "Skrót CASE oznacza",
        a: [
            "programy wykorzystywane do wspomagania czynności procesu tworzenia oprogramowania",
            "funkcja pozwalająca testować oprogramowanie",
            "funkcja wyboru modelu tworzenia oprogramowania",
            "oprogramowanie zaakceptowane po fazie testowej"
    ]},
    {
        q: "Wymagania stawiane systemowi komputerowemu to",
        a: [
            "szczegółowo ustalają usługi systemu i ograniczenia",
            "wyrażenia w języku naturalnym oraz diagramy o usługach oczekiwanych od systemu oraz o ograniczeniach",
            "jakie usługi ma oferować system, jak ma reagować na określone dane wejściowe",
            "pochodzą od dziedziny zastosowań systemu, odzwierciedlają jej charakterystykę"
    ]},
    {
        q: "Proces inżynierii wymagań to proces",
        a: [
            "wynajdowania, analizowania, dokumentowania",
            "wynajdowania, dokumentowania, wdrażania",
            "planowania, dokumentowania, implementowania",
            "analizowania, implementowania, testowania"
    ]},
    {
        q: "Wymagania użytkownika to",
        a: [
            "wyrażenia w języku naturalnym i diagramy o usługach oczekiwanych od systemu oraz o ograniczeniach",
            "wymagania funkcjonalne i niefunkcjonalne zrozumiałe dla użytkowników systemu posiadających wiedzę techniczną",
            "usługi oferowane przez system po zakończeniu procesu projektowania",
            "wyrażenia w języku naturalnym, przeznaczone do zapisywania wymagań systemowych"
    ]},
    {
        q: "Wymagania systemowe",
        a: [
            "szczegółowo ustalają usługi i ograniczenia systemu. Dokumentacja wymagań systemowych zwana czasem specyfikacją funkcjonalną powinna być precyzyjna",
            "nie zależą od rodzaju tworzonego oprogramowania, spodziewanych użytkowników oprogramowania i rodzaju wytwarzanego systemu",
            "opisują właściwości i ograniczenia systemu np. niezawodność, czas odpowiedzi, ilość miejsca na dysku",
            "ustalają struktury organizacyjne, przepisy prawne, statuty, zarządzenia, instrukcje, itd., które pośrednio lub bezpośrednio określają funkcje wykonywane przez planowany system"
    ]},
    {
        q: "Specyfikacja projektu to",
        a: [
            "abstrakcyjny opis projektu oprogramowania",
            "weryfikowalny opis wymagań funkcjonalnych i niefunkcjonalnych",
            "rzeczywisty opis projektu oprogramowania",
            "dokument określający ramy projektu"
    ]},
    {
        q: "Wymagania funkcjonalne",
        a: [
            "stwierdzają, jakie usługi ma oferować system, jak ma reagować na określone dane wejściowe , oraz jak ma się zachowywać w określonych sytuacjach",
            "określają ograniczenia usług i funkcji systemu",
            "nie zależą od rodzaju tworzonego oprogramowania, spodziewanych jego użytkowników oraz rodzaju wytwarzanego systemu",
            "żadna z odpowiedzi nie jest poprawna"
    ]},
    {
        q: "Wymaganie niefunkcjonalne",
        a: [
            "ogranicza usługi i funkcje systemu",
            "to ograniczenie dotyczące projektowania systemu",
            "dotyczy bezpośrednio konkretnych funkcji systemu",
            "wynika z czynników zewnętrznych"
    ]},
    {
        q: "Wymagania dziedzinowe",
        a: [
            "pochodzą od dziedziny zastosowań systemu, odzwierciedlają jej charakterystykę. Mogą być funkcjonalne lub niefunkcjonalne",
            "pozwalają umieścić system w kontekście biznesowym, technicznym i środowiskowym",
            "są abstrakcyjnym opisem projektu oprogramowania, który jest podstawą bardziej szczegółowego projektu i implementacji",
            "wynikają ze strategii i procedur w firmie klienta i w firmie wytwórcy"
    ]},
    {
        q: "Uczestnik w analizie wymagań",
        a: [
            "osoba która będzie pracować z systemem oraz osoby na które system będzie miał wpływ",
            "osoba która będzie na systemie zarabiać",
            "wszystkie odpowiedzi są poprawne",
            "żadna z odpowiedzi nie jest poprawna"
    ]},
    {
        q: "Studium wykonalności odpowiada na pytanie",
        a: [
            "wszystkie odpowiedzi są poprawne",
            "czy system przyczyni się do realizacji celów przedsiębiorstwa?",
            "czy system może być zaimplementowany z użyciem dostępnych technologii w ramach ustalonego budżetu i ograniczeń czasowych?",
            "czy system może być zintegrowany z istniejącymi systemami, które już zainstalowano?"
    ]},
    {
        q: "Skrót UML w inżynierii oprogramowania oznacza: ",
        a: [
            "Unified Modeling Language",
            "Unique Modeling Language",
            "Universal Modeling Library",
            "Unusual Modeling Language"
    ]},
    {
        q: "W UML można wyróżnić następujące widoki modelu",
        a: [
            "logiczny, procesu, fizyczny, konstrukcji, przypadków użycia",
            "dynamiczny, statyczny, ogólny",
            "ogólny, szczegółowy, domyślny",
            "procesu, główny, dynamiczny, statyczny"
    ]},
    {
        q: "Diagramy UML można ogólnie podzielić na",
        a: [
            "dynamiczne i statyczne",
            "dynamiczne i nieokreślone",
            "statyczne i ogólne",
            " proste i złożone"
    ]},
    {
        q: "Elementami składowymi UML są",
        a: [
            "elementy, związki, diagramy",
            "klasy, związki, funkcje",
            "funkcje, elementy, diagramy",
            "elementy, klasy, metody"
    ]},
    {
        q: "Stereotyp w UML",
        a: [
            "wszystkie odpowiedzi są poprawne",
            "jest reprezentowany przez ikonę",
            "jest reprezentowany przez słowo ujęte w << >>",
            "służy do zmieniania i doprecyzowania elementów modelu"
    ]},
    {
        q: "W modelowaniu wymagań, aktorów należy traktować jako",
        a: [
            "Nierzeczywistych ludzi, mogą być czarnymi skrzynkami",
            "Klasę główną",
            "Interfejs klasy",
            "Projektantów aplikacji"
    ]},
    {
        q: "Na diagramie przypadków użycia między aktorami może zachodzić związek",
        a: [
            "Uogólnienia inaczej:(generalizacja lub dziedziczenie) co powoduje hierarchizacje aktorów",
            "Wiązań",
            "Twardego wiązania",
            "Szeregowego dodania"
    ]},
    {
        q: "Na diagramie przypadków użycia linia komunikacji",
        a: [
            "Oznacza komunikację między aktorem a przypadkiem użycia",
            "Linia komunikacji nie istnieje",
            "Służy do wpisywania poleceń",
            "Służy do komunikacji obiektów"
    ]},
    {
        q: "Diagram czynności UML umożliwia",
        a: [
            "Pokazanie w jaki sposób system osiąga zamierzone cele",
            "Pokazanie kolejności interakcji pomiędzy uczestnikami",
            "Przedstawienie kolejności interakcji pomiędzy uczestnikami",
            "interakcje z wewnętrznymi uczestnikami"
    ]},
    {
        q: "Na diagramie czynności UML",
        a: [
            "Pokazane są interakcje z zewnętrznymi uczestnikami",
            "Pokazane są interakcje z wewnętrznymi uczestnikami",
            "Występuje kolejności interakcji pomiędzy uczestnikami",
            "Pokazuje testy aplikacji"
    ]},
    {
        q: "Diagram sekwencji UML umożliwia",
        a: [
            "Przedstawienie kolejności interakcji pomiędzy uczestnikami",
            "Kolejność wykonywania algorytmu",
            "Szkielet klas",
            "interakcje z zewnętrznymi uczestnikami"
    ]},
    {
        q: "Każdy uczestnik na diagramie sekwencji UML posiada",
        a: [
            "linie życia",
            "pętlę",
            "wywołanie",
            "rekursję"
    ]},
    {
        q: "Wywołanie metody danego uczestnika to inaczej",
        a: [
            "wysłanie komunikatu",
            "odebranie komunikatu",
            "utworzenie obiektu",
            "zniszczenie obiektu"
    ]},
    {
        q: "Stan obiektu klasy to",
        a: [
            "atrybut klasy (dane)",
            "pola klasy",
            "metody klasy",
            "nazwa klasy"
    ]},
    {
        q: "Zachowanie klasy to",
        a: [
            "operacje jakie klasa może wykonać",
            "typ zwracany przez metodę klasy",
            "tworzenie obiektu danej klasy",
            "pola występujące w klasie"
    ]},
    {
        q: "Diagram klas prezentuje",
        a: [
            "typy obiektów w programie",
            "klasy nie występujące w programie",
            "obiekty występujące w programie",
            "metody występujące w programie "
    ]},
    {
        q: "Instancją danej klasy nazywa się",
        a: [
            "obiekty danej klasy",
            "nazwa danej klasy",
            "metody danej klasy",
            "pola danej klasy"
    ]},
    {
        q: "Hermetyzacja umożliwia",
        a: [
            "ukrywanie szczegółów implementacji klasy",
            "zmianę szczegółów implementacji klasy",
            "pełny dostęp do klas bez wykorzystywania metod",
            "dostęp do funkcji zaprzyjaźnionych innych klas"
    ]},
    {
        q: "Hermetyzacja oznacza, że",
        a: [
            "obiekt powinien zawierać dane i instrukcje",
            "obiekt powinien zawierać tylko dane bez instrukcji",
            "obiekt powinien zawierać tylko instrukcje bez danych",
            "obiekt powinien być pusty"
    ]},
    {
        q: "W UML klasa reprezentowana jest przez",
        a: [
            "prostokąt z nazwą klasy oraz opcjonalnie jej atrybuty oraz operacje(metody)",
            "kwadrat z nazwą klasy oraz opcjonalnie jej atrybuty oraz operacje(metody)",
            "równoległobok z nazwą klasy oraz opcjonalnie jej atrybuty oraz operacje(metody)",
            "romb z nazwą klasy oraz opcjonalnie jej atrybuty oraz operacje(metody)"
    ]},
    {
        q: "Publiczny poziom dostępu do elementu klasy oznacza, że",
        a: [
            "elementy danej klasy są widoczne dla każdego",
            "elementy danej klasy mają ograniczoną widoczność",
            "element jest widoczny tylko dla klasy dziedziczącej",
            "element danej klasy jest dostępny ale tylko przy użyciu metod"
    ]},
    {
        q: "Poziomy dostępu wymienione od najmniej restrykcyjnego do najbardziej restrykcyjnego poziomu to: ",
        a: [
            "publiczny–chroniony-pakietowy-prywatny",
            "pakietowy-publiczny-prywatny-chroniony",
            "publiczny-pakietowy-chroniony-prywatny",
            "pakietowy-publiczny-chroniony-prywatny"
    ]},
    {
        q: "Poziomy dostępu wymienione od najbardziej restrykcyjnego do najmniej restrykcyjnego poziomu",
        a: [
            "prywatny-pakietowy-chroniony-publiczny",
            "pakietowy-prywatny-chroniony-publiczny",
            "chroniony-prywatny--pakietowy-publiczny",
            "chroniony-pakietowy-prywatny-publiczny"
    ]},
    {
        q: "Związki pomiędzy klasami od najsłabszego do najsilniejszego",
        a: [
            "zależność - asocjacja - agregacja - kompozycja - dziedziczenie(generalizacja)",
            "asocjacja- agregacja – kompozycja – zależność – dziedziczenie(generalizacja)",
            "dziedziczenie(generalizacja) – kompozycja – agregacja – asocjacja – zależność",
            "kompozycja – zależność – asocjacja – dziedziczenie(generalizacja) – agregacja"
    ]},
    {
        q: "Związki pomiędzy klasami od najsilniejszego do najsłabszego",
        a: [
            "dziedziczenie(generalizacja) - kompozycja - agregacja - asocjacja - zależność",
            "asocjacja - agregacja – kompozycja – zależność – dziedziczenie(generalizacja)",
            "dziedziczenie(generalizacja) – zależność – agregacja – asocjacja – kompozycja",
            "kompozycja – zależność – asocjacja – dziedziczenie(generalizacja) - agregacja"
    ]},
    {
        q: "Związek zależności oznacza, że",
        a: [
            "gdy obiekty jednej klasy działają wykorzystując przelotnie obiekty innej klasy",
            "gdy obiekty jednej klasy działają wykorzystując obiekty innej klasy przez dłuższą chwile",
            "klasa dziedziczy inwarianty z więcej niż jednej klasy",
            "żadna odpowiedź nie jest poprawna"
    ]},
    {
        q: "Związek asocjacji oznacza, że",
        a: [
            "gdy obiekty jednej klasy działają wykorzystując obiekty innej klasy, przez dłuższą chwile",
            "Asocjacja reprezentuje związek typu całość-część",
            "wszystkie odpowiedzi są poprawne",
            "asocjacja wskazuje na trwałe powiązanie pomiędzy obiektami danych"
    ]},
    {
        q: "Związek agregacji oznacza, że",
        a: [
            "klasa zawiera, ale jednocześnie współdzieli odwołanie do obiektów innej",
            "agregacja to związek opisujący dziedziczenie po klasach",
            "jedna klasa jest rodzajem innej",
            "klasa która nie ma swoich obiektów"
    ]},
    {
        q: "Związek kompozycji oznacza, że",
        a: [
            "klasa zawiera obiekty innej",
            "tej klasy nie można nazwać złożeniem",
            "nie jest związkiem typu całość-część",
            "Na diagramie, kompozycję oznacza się za pomocą linii zakończonej strzałką"
    ]},
    {
        q: "Związek dziedziczenia oznacza, że",
        a: [
            "jedna klasa jest rodzajem innej",
            "gdy obiekty jednej klasy działają wykorzystując obiekty innej klasy przez dłuższą chwile",
            "klasa nie posiada własnych obiektów",
            "jedna klasa nie jest rodzajem innej"
    ]},
    {
        q: "Klasa abstrakcyjna to",
        a: [
            "klasa która nie ma swoich obiektów",
            "klasa, która może mieć swoich reprezentantów pod postacią obiektów",
            "klasa dziedziczy inwarianty z więcej niż jednej klasy",
            "żadna z odpowiedzi nie jest poprawna"
    ]},
    {
        q: "Na diagramie obiektów UML przedstawia się",
        a: [
            "instancje obiektów i połączenie między nimi",
            "zmiany stanów obiektów w czasie pod wpływem interakcji z użytkownikiem",
            "obiekty oraz przypadki w których są one tworzone i kasowane",
            "tylko te obiekty, które tworzone są przez aktorów"
    ]},
    {
        q: "Dwa obiekty na diagramie mogą być ze sobą połączone tylko gdy",
        a: [
            "występuje asocjacja lub agregacja",
            "są tej samej klasy i występuje połączenie generalizacji jednego z nich",
            "ich klasy implementują co najmniej jeden wspólny interfejs",
            "należą do tego samego pakietu"
    ]},
    {
        q: "Komponent to",
        a: [
            "hermetyzowana, możliwa do powtórnego użycia część oprogramowania",
            "inna nazwa obiektu klasy",
            "obiekt klasy, która dziedziczy z dwóch innych klas",
            "każdy sprzęt elektroniczny, który widoczny jest w diagramie wdrożenia"
    ]},
    {
        q: "Diagram komponentów UML umożliwia",
        a: [
            "łatwe modelowania architektury systemu",
            "pokazanie z jakich pól i metod składają się poszczególne klasy",
            "ukazanie pełnego stanu obiektu i zmian w nim zachodzących",
            "ukazanie na osi czasu etapów powstawania aplikacji"
    ]},
    {
        q: "Pakiety w języku UML służą do",
        a: [
            "grupowania podobnych elementów, czasem grupują podobne przypadki użycia",
            "ujednolicenia nazw w projekcie - wszystkie elementy pakietu mają tę samą nazwę",
            "pokazania jakie informacje są przekazywane między obiektami",
            "grupowania wielu obiektów tej samej klasy"
    ]},
    {
        q: "Na diagramach komunikacji UML przedstawia się",
        a: [
            "połączenia wymagane do przekazania komunikatów",
            "głównie treść komunikatu z określeniem możliwych odbiorców",
            "komunikaty, które w określonych przypadkach zostaną wyświetlone użytkownikom",
            "dużą ilość informacji dotyczących interakcji, np. bloki komunikatów"
    ]},
    {
        q: "Kolejność wywołania komunikatów na diagramach komunikacji UML jest odczytywana dzięki",
        a: [
            "numeracji komunikatów",
            "etykiecie liczbowej",
            "symboli komunikatów",
            "priorytetu komunikatu"
    ]},
    {
        q: "Kolejność wywołania komunikatów na diagramach sekwencji UML jest odczytywana dzięki",
        a: [
            "osi czasu",
            "ponumerowania",
            "od najważniejszych",
            "losowo"
    ]},
    {
        q: "Charakterystyczną cechą diagramu czasowego UML jest",
        a: [
            "ukazują zależności czasowe, przedstawiają widok procesu",
            "modelowane czynności i zakresu odpowiedzialności elementów bądź użytkowników systemu",
            "sposób wymiany komunikatów pomiędzy obiektami uczestniczącymi w interakcji",
            "pokazywanie podziału systemów programowych na mniejsze podsystemy"
    ]},
    {
        q: "Na przeglądowym diagramie interakcji UML znaleźć się mogą",
        a: [
            "diagram czynności, diagram interakcji, diagram komunikacji, diagram czasowy",
            "diagram widoku, diagram klas, diagram interakcji, diagram czynności",
            "diagram klas, diagram komunikacji, diagram czasowy",
            "diagram szczegółowy, diagram komunikacji, diagram widoku, diagram czynności"
    ]},
    {
        q: "Diagram maszyny stanowej UML przedstawia: ",
        a: [
            "stan obiektu i zachodzące w nim zmiany",
            "związki istniejące pomiędzy częściami systemu, które współpracując dostarczają pewnej funkcjonalności",
            "modelowanie fizycznego i logicznego podziału systemu",
            "dynamikę systemu"
    ]},
    {
        q: "Na diagramie maszyny stanowej UML zmiana stanu obiektu spowodowana jest",
        a: [
            "użyciem wyzwalacza",
            "wywołaniem procedury",
            "przeniesieniem lub doborem klasyfikatorów",
            "ustalenie horyzontu czasowego diagramu"
    ]},
    {
        q: "Stan nieaktywny na diagramie stanów UML to",
        a: [
            "obiekt z którego wychodzimy",
            "zniszczenie adekwatnego obiektu",
            "tworzenie obiektu",
            "modyfikacja obiektu"
    ]},
    {
        q: "Diagram wdrożenia UML przedstawia",
        a: [
            "widok fizyczny, jak wdrażane są programy na sprzęcie",
            "zbiór obiektów i ich związków w danej chwili",
            "sposób wymiany komunikatów pomiędzy obiektami uczestniczącymi w interakcji",
            "egzemplarze elementów z diagramu klas"
    ]},
    {
        q: "Artefakty na diagramie wdrożenia UML to",
        a: [
            "pliki (wykonywalne, biblioteczne, źródłowe, konfiguracyjne)",
            "bloki definiujące grupę komunikatów wspólnie posiadającą pewną właściwość",
            "sposoby przedstawiania klas",
            "przypadki użycia które pokazują, co powinien robić system"
    ]},
    {
        q: "Węzły na diagramie wdrożenia UML to",
        a: [
            "programowy lub sprzętowy zasób, który może zawierać oprogramowanie lub powiązane z nim pliki",
            "węzły które mogą zawierać oprogramowanie lub powiązane z nimi pliki",
            "zasób programowy, który zawiera powiązane z nim pliki",
            "powiązania pomiędzy istniejącymi klasami"
    ]},
    {
        q: "Pomiędzy węzłami na diagramie wdrożenia UML może zachodzić",
        a: [
            "komunikacja (odczyt, zapis…)",
            "agregacja wsteczna",
            "całkowity brak komunikacji",
            "powiązania podobne jak w obiektach"
    ]},
    {
        q: "W modelowaniu CRC taka cecha klasy jak sekwencyjność oznacza",
        a: [
            "nie można przeskakiwać o kilka zadań, trzeba je wykonywać po kolei",
            "klasa nie może mieć takiej cechy jak sekwencyjność",
            "zadania można wykonywać w obrębie danej klasy",
            "zadania mogą być wykonywane losowo"
    ]},
    {
        q: "W modelowaniu CRC taka cecha klasy jak trwałość oznacza: ",
        a: [
            "zawartość się nie zmieni",
            "zawartość zmieni się w obrębie danej klasy",
            "zawartość zmieni się tylko w klasie bazowej w dziedziczony już nie",
            "zawartość nie zmieni się w tylko w obiektach statycznych"
    ]},
    {
        q: "W modelowaniu CRC taka cecha klasy jak integralność oznacza: ",
        a: [
            "że klasę można wykorzystać w przyszłości do innych celów",
            "klasa może dziedziczyć wielokrotnie",
            "integralność wyklucza trwałość jako cechę",
            "nie można korzystać z enkapsulacji"
    ]},
    {
        q: "Architektura systemu komputerowego określa",
        a: [
            "strukturę połączeń jego składników programowych , widoczne cechy tych składników i połączenia jakie między nimi zachodzą",
            "specyfikację sprzętu i programów w nim zainstalowanych",
            "oprogramowanie systemowe, oprogramowanie narzędziowe, oprogramowanie użytkowe",
            "wszystkie odpowiedzi są prawidłowe"
    ]},
    {
        q: "Minimalny opis wzorca składa się z",
        a: [
            "nazwy wzorca, rozwiązanego problemu, rozwiązania, konsekwencji",
            "nazwy wzorca, rozwiązanego problemu, rozwiązania",
            "nazwy wzorca, rozwiązanego problemu, rozwiązania, algorytmu",
            "nazwy wzorca, rozwiązanego problemu, rozwiązania,  uzasadnienia"
    ]},
    {
        q: "Wzorce projektowe w Inżynierii Oprogramowania dzieli się na",
        a: [
            "to co robią, ich zakres",
            "kreacyjne, strukturalne, czynnościowe",
            "obiektowe, strukturalne, liniowe",
            "Kenta Becka, Warda Cunninghama"
    ]},
    {
        q: "Wzorce projektowe w Inżynierii Oprogramowania dzieli się na",
        a: [
            "to co robią kreacyjne/strukturalne/czynnościowe, ich zakres klasowe/obiektowe",
            "kreacyjne(konstrukcyjne), strukturalne, czynnościowe",
            "obiektowe, klasowe",
            "złożone, proste, mieszane"
    ]},
    {
        q: "Przeznaczeniem wzorca projektowego Adapter jest",
        a: [
            "przekształca interfejs klasy na taki jakiego klienci oczekują",
            "abstrakcyjne połączenie między Obserwowanym a Obserwatorem",
            "przedstawienie hierarchii obiektów część-całość",
            "konstrukcja rodziny powiązanych ze sobą algorytmów"
    ]},
    {
        q: "Uczestnikami wzorca projektowego Adapter są",
        a: [
            "cel, klient, adaptowany, adapter",
            "cel, klient, adapter",
            "cel, klient, adaptowany, adapter, testerzy",
            "cel, klient, adaptowany, adapter, obserwator"
    ]},
    {
        q: "Uczestnikami wzorca projektowego Obserwator są",
        a: [
            "obserwator, obserwator konkretny, obserwowany, obserwowany konkretny",
            "obserwowany, obserwator, klient, obserwator konkretny",
            "obserwator konkretny, obserwator, obserwowany, odwiedzający",
            "obserwator, obserwowany, obserwator konkretny, interator"
    ]},
    {
        q: "Przeznaczeniem wzorca projektowego Strategia jest",
        a: [
            "umożliwienie zmiany algorytmu niezależnie od użytkujących go klientów",
            "przekształcenie interfejsu klasy na taki, jakiego klienci oczekują",
            "rozdzielenie sposobu tworzenia obiektów od ich reprezentacji",
            "uproszczenie komunikacji wielu obiektów"
    ]},
    {
        q: "Uczestnikami wzorca projektowego Strategia są",
        a: [
            "kontekst, strategia, strategia konkretna",
            "klient, obserwator, kontekst",
            "strategia konkretna, kontekst, obserwator",
            "strategia, kontekst, klient"
    ]},
    {
        q: "Przeznaczeniem wzorca projektowego Kompozyt jest",
        a: [
            "składa obiekty w struktury drzewiaste, reprezentujące hierarchię typu część-całość",
            "umożliwienie tworzenia obiektów danej klasy bądź klas z wykorzystaniem już istniejącego obiektu",
            "zmiana operacji wykonywanych na elementach klasy bez zmiany struktury tej klasy",
            "umożliwienie zmiany zachowania obiektu w momencie zmiany jego stanu"
    ]},
    {
        q: "Uczestnikami wzorca projektowego Kompozyt są: ",
        a: [
            "kompozyt, klient, komponent, liść",
            "kontekst, klient, komponent, liść",
            "klient, obserwator, komponent, liść, kompozyt",
            "kompozyt, komponent, odwiedzający, klient"
    ]},
    {
        q: "Uczestnikami wzorca projektowego Iterator są",
        a: [
            "iterator,  iterator konkretny, agregat, agregat konkretny",
            "agregat, cel, iterator, agregat konkretny",
            "adapter, iterator, agregat, cel",
            "agregat, iterator, iterator konkretny, adapter"
    ]},
    {
        q: "Przeznaczeniem wzorca projektowego Singleton jest: ",
        a: [
            "zapewnienie że klasa ma tylko jeden egzemplarz i zapewnia globalny dostęp do niego",
            "parametryzacja klientów obiektami poleceń, wsparcie dla poleceń odwracalnych",
            "dostarczenie „zjednoczonego” i uproszczonego interfejsu, zestawu interfejsów z danego podsystemu",
            "umożliwienie ukrycie szczegółów implementacji klasy"
    ]},
    {
        q: "Wady wzorca projektowego Singleton to",
        a: [
            "łamie zasadę jednej odpowiedzialności",
            "klasa zaimplementowana z użyciem wzorca singleton może samodzielnie kontrolować liczbę swoich instancji istniejących w systemie",
            "tworzenie nowej instancji ma charakter leniwy, tj. zachodzi dopiero przy pierwszej próbie użycia. Jeśli żaden komponent nie zdecyduje się korzystać z klasy, jej instancji nie będą niepotrzebnie przydzielone zasoby",
            "proces pobierania instancji klasy jest niewidoczny dla użytkownika. Nie musi on wiedzieć, czy w chwili wywołania metody instancja istnieje czy dopiero jest tworzona,"
    ]},
    {
        q: "Uczestnikami wzorca projektowego Fabryka abstrakcyjna są",
        a: [
            "abstrakcyjna Fabryka, konkretna Fabryka, abstrakcyjny Produkt, konkretny produkt, klient",
            "abstrakcyjny produkt, abstrakcyjna fabryka, klient",
            "konkretna Fabryka, abstrakcyjny produkt, klient",
            "abstrakcyjna Fabryka, konkrenta Fabryka, abstrakcyjny Produkt, abstrakcyjny klient"
    ]},
    {
        q: "Uczestnikami wzorca projektowego Metoda wytwórcza są",
        a: [
            "produkt, konkretny produkt, kreator, konkretny kreator",
            "konkretny produkt, kreator, konkretnyKreator",
            "kreator, konkretny kreator, klient",
            "konkretny produkt, konkretnyKreator"
    ]},
    {
        q: "Wzorzec Model-Widok-Kontroler zaliczany jest do grupy wzorców: ",
        a: [
            "architektonicznych",
            "kreacyjnych",
            "strukturalnych",
            "obiektowych"
    ]},
    {
        q: "Dobry test to taki, który",
        a: [
            "z dużym prawdopodobieństwem pozwala znaleźć błąd wcześniej nie wykryty",
            "wymaga niskich nakładów pracy testera",
            "jest wykonywany przez maszynę",
            "zwraca najmniejszą ilość błędów"
    ]},
    {
        q: "Istotą testowania oprogramowania prócz wykrywaniem błędów, operatywności, obserwowalności, sterowności, stabilności jest",
        a: [
            "zrozumiałość",
            "złożoność",
            "skomplikowanie",
            "różnorodność"
    ]},
    {
        q: "Weryfikacja/Walidacja systemu oznacza sprawdzenie",
        a: [
            "czy system został zbudowany dobrze",
            "czy system pracuje szybko",
            "czy system jest przyjazny dla użytkownika",
            "czy system jest otwarty na wiele platform"
    ]},
    {
        q: "Statyczna weryfikacja systemu oznacza",
        a: [
            "testowanie przed uruchomieniem systemu",
            "testowanie działającego systemu",
            "analizowanie wyników po zakończeniu działania systemu",
            "szczegółowe rozpisanie funkcji programu"
    ]},
    {
        q: "Testy czarnej skrzynki",
        a: [
            "nie biorą pod uwagę wewnętrznej struktury programu, wszystkie rodzaje testowania",
            "należą do działu testów strukturalnych",
            "dostarczają dokładną informację na temat przyczyny wystąpienia błędu w programie",
            "posiadają mniejszą szansę na wykrycie błędnych wykonań, niż test białej skrzynki"
    ]},
    {
        q: "Inspekcje oprogramowania polegają na",
        a: [
            "przeglądaniu źródłowej reprezentacji systemu i szukaniu błędów. Sprawdzane są artefakty celem wykrycia anomalii",
            "testowaniu od ogółu do szczegółu",
            "uruchomieniu oprogramowania na danych testowych i badaniu wyników wygenerowanych przez to oprogramowanie",
            " badaniu zachowania oprogramowania celem sprawdzenia, czy jest zgodne ze specyfikacją"
    ]},
    {
        q: "Analizując pokrycie kodu, pokrycie instrukcji oznacza, że",
        a: [
            "każda instrukcja jest sprawdzana",
            "sprawdzane są czy i jak często są wykonywane instrukcje z pojedynczych wierszy programu",
            "sprawdzane są tylko istotne instrukcje",
            "sprawdzenie zależności od danych i branie ich pod uwagę"
    ]},//Tu nowe rzeczy
    {
        q: "Refaktoryzacja programu nie zmienia",
        a: [
            "jego zachowania",
            "jego pielęgnowalności",
            "jego kosztu",
            "jego struktury"
    ]},
    {
        q: "Pielęgnacja oprogramowania to",
        a: [
            "czynności modyfikujące program po jego dostarczeniu i wdrożeniu",
            "przygotowanie oprogramowania do dostarczenia go klientowi",
            "przygotowanie oprogramowania do testowania",
            "czynności modyfikujące program przed jego dostarczeniem i wdrożeniem"
    ]},
    {
        q: "Wadą modelu opartego na prototypowaniu jest",
        a: [
            "dodatkowy koszt budowy prototypu",
            "skomplikowana faza wstępnego projektu systemu",
            "długa przerwa w kontaktach z klientem",
            "możliwość implementacji systemu tylko w językach obiektowych"
    ]},
    {
        q: "Ograniczenie 'pre:x>0' nałożone na metodę 'f(x:int):int' ozncza",
        a: [
            "wartość argumentu metody nie może być ujemna",
            "wartość argumentu metody nie może być większa od zera",
            "metoda ma zwracać wartość mniejszą od zera",
            "metoda ma zwracać wartość dodatnią"
    ]},
    {
        q: "Architektura warstwowa systemu oznacza, że",
        a: [
            "w systemie występuje kilka warstw realizujących coraz bardziej niskopoziomowe funkcje",
            "dane wejściowe systemu są przetwarzane przez kolejne moduły",
            "program główny uruchamia pewną liczbę podprogramów, które z kolei mogą uruchamiać kolejne podprogramy",
            "składniki systemu obejmują dane wraz z działającymi na nich operacjami"
    ]},
    {
        q: "Przeznaczeniem wzorca projektowego Obserwator jest",
        a: [
            "aktualizacja wszystkich obiektów zależnych od obiektu obserwowanego",
            "zmiana algorytmu niezależnie od używających go klientów",
            "złożenie obiektów w struktury drzewiaste reprezentujące hierarchię typu część-całość",
            "przekształcenie interfejsu klasy na taki, jakiego klienci oczekują"
    ]},
    {
        q: "Sposobem zapewnienia wysokiej jakości programu tworzonego zgodnie z techniką programowania ekstremalnego jest",
        a: [
            "stosowanie prostych rozwiązań i unikanie przedwczesnej optymalizacji",
            "właściwe dokumentowanie każdego kroku procesu",
            "zakładanie długich okresów czasu pomiędzy kolejnymi wydaniami systemu",
            "prezentacja klientowi wyłącznie w pełni ukończonego programu"
    ]},
    {
        q: "Makro CPPUNIT_ASSERT_EQUAL(a,b) z biblioteki CppUnit umożliwia",
        a: [
            "sprawdzenie, czy wartość b równa jest wartości a",
            "sprawdzenie, czy wartość a jest równa zeru z dokładnością do b",
            "sprawdzenie, czy funkcja a rzuca wyjątek b",
            "sprawdzenie, czy wartość a jest mniejsza od b"
    ]},
    {
        q: "Stereotyp w UML jest symbolizowany przez i oznacza",
        a: [
            "podwójne nawiasy trójkątne i oznacza specjalne użycie elementu",
            "nawias kwadratowy i oznacza specjalny komentarz",
            "podwójny nawias okrągły i oznacza warunek",
            "nawiaz klamrowy i oznacza komentarz"
    ]},
    {
        q: "Makro CPPUNIT_ASSERT_THROW(a,b) z biblioteki CppUnit umożliwia",
        a: [
            "sprawdzenie, czy funkcja a rzuca wyjątek b",
            "sprawdzenie, czy wartość b jest równa wartości a",
            "sprawdzenie, czy wartość a jest większa od wartości b",
            "automatyczną konwersję obiektu typu a na obiekt typu b"
    ]},
    {
        q: "Proces pre-processingu testu oznacza",
        a: [
            "ustawienie stanu systemu do wykonywania wariantu testu",
            "automatyczne kończenie testów",
            "automatyczne uruchomienie testów",
            "\"sprzątanie\" systemu po wykonaniu testu"
    ]},
    {
        q: "Wysyłanie komunikatu asynchronicznego powoduje, że",
        a: [
            "nadawca nie czeka na zakończenie obsługi komunikatu przez odbiorcę",
            "odbiorca zostaje bezwarunkowo zniszczony z chwilą zakończenia obsługi komunikatu",
            "nadawca czeka na zakończenie obsługi komunikatu przez odbiorcę",
            "nadawca zostaje zniszczony z chwilą odebrania komunikatu przez odbiorcę"
    ]},
    {
        q: "Wyrażenie 'zmienna<>2' w języku OCL oznacza",
        a: [
            "zmienna musi mieć wartość różną od 2",
            "zmienna musi mieć wartość będącą wielokrotnością liczby 2",
            "zmienna musi mieć wartość dodatnią",
            "zmienna musi mieć wartość równą 2"
    ]},
    {
        q: "Przykładowym typem wymagań niefunkcjonalnych jest",
        a: [
            "wszystkie wymienione wymagania są wymaganiami niefunkcjonalnymi",
            "wymaganie przenośności",
            "wymaganie implementacyjne",
            "wymaganie efektywnościowe"
    ]},
    {
        q: "Wysyłanie komunikatu synchronicznego powoduje, że",
        a: [
            "nadawca czeka na zakończenie obsługi komunikatu przez odbiorcę",
            "nadawca zostaje zniszczony z chwilą odebrania komunikatu przez odbiorcę",
            "odbiorca zostaje bezwarunkowo zniszczony z chwilą zakończenia obsługi komunikatu",
            "nadawca nie czeka na zakończenie obsługi komunikatu przez odbiorcę"
    ]},
    {
        q: "Wzorce projektowe w Inżynierii Oprogramowania dzieli się na",
        a: [
            "kreacyjne, strukturalne i czynnościowe",
            "statyczne i dynamiczne",
            "obiektowe i funkcjonalne",
            "kreacyjne i destrukcyjne"
    ]},
    {
        q: "Sposobem zapewnienia wysokiej jakości programu tworzonego zogdnie z techniką programowania ekstremalnego jest",
        a: [
            "pisanie testów przed właściwym kodem i automatyczne ich wykonywanie",
            "prezentacja klientowi wyłącznie w pełni ukończonego programu",
            "właściwe dokumentowanie każdego kroku procesu",
            "zakładanie długich okresów czasu pomiędzy kolejnymi wydaniami systemu"
    ]},
    {
        q: "Wzorce projektowe w Inżynierii Oprogramowania dzieli się na",
        a: [
            "klasowe i obiektowe",
            "statyczne i dynamiczne",
            "obiektowe i funkcjonalne",
            "kreacyjne i destrukcyjne"
    ]},
    {
        q: "Liczebność w oznaczeniu związku 1..* przy danej klasie oznacza, że",
        a: [
            "musi występować co najmniej jeden obiekt klasy",
            "może występować dowolna liczba obiektó klasy",
            "musi wystepować dokładnie jeden obiekt klasy",
            "nie może występować liczba obiektówe danej klasy większa niż 1"
    ]},
    {
        q: "Przypadek użycia odpowiada wymaganiom",
        a: [
            "funkcjonalnym",
            "wydajnościowym",
            "dziedzinowym",
            "niefunkcjonalnym"
    ]},
	{
        q: "Na diagramie obiektów UML przedstawia się",
        a: [
            "instancje klas i relacje między nimi",
            "klasy i zależności między nimi",
            "stan obiektów i zachodzące w nim zmiany",
            "wymianę komunikatów między uczestnikami"
    ]},
	{
        q: "Architektura systemu komputerowego określa",
        a: [
            "widoczne z zewnątrz cechy i związki składników tego systemu",
            "wygląd graficznego interfejsu użytkownika",
            "wymagania sprzętowe systemu komputerowego",
            "sposób uruchamiania programu głównego"
    ]},
	{
        q: "Statyczna weryfikacja systemu oznacza",
        a: [
            "przeprowadzenie inspekcji kodu",
            "odpowiedni projekt systemu",
            "uruchamianie oprogramowania w celu prezentacji klientowi",
            "utworzenie odpowiedniej liczby przypadków testowych"
    ]},
    {
        q: "Pomiędzy przypadkami użycia mogą zachodzić relacje",
        a: [
            "zawierania, rozszerzania i generalizacji",
            "zawierania i kompozycji",
            "asocjacji, agregacji i kompozycji",
            "generalizacji i zalezności"
    ]},
    {
        q: "Oprogramowanie to",
        a: [
            "programy komputerowe, cała związana z nimi dokumentacja i dane kofiguracyjne",
            "tylko programy komputerowe",
            "programy komputerowe i ich konfiguracja",
            "wyłącznie dokumentacja i dane konfiguracyjne"
    ]},
    {
        q: "Przypadek użycia to",
        a: [
            "użycie danego systemu w celu spełnienia jednego bądź więcej wymagań użytkownika",
            "czarna skrzynka, niekoniecznie odpowiadająca rzeczywistym ludziom, za to koniecznie współdziałająca z systemem",
            "linia łącząca aktora z systemem",
            "podwójne nawiazy klamrowe z komentarzem wewnątrz"
    ]},
    {
        q: "Port w języku UML służy do",
        a: [
            "grupowania podobnych interfejsów",
            "przedstawiania architektury systemu",
            "grupowania podobnych klas",
            "grupowania podobnych przypadków użycia"
    ]},
    {
        q: "We wzorcu Model-Widok-Kontroler wykorzystuje się wzorce",
        a: [
            "Strategia, Kompozyt, Obserwator",
            "Strategia, Kompozyt, Singleton",
            "Strategia, Fabryka abstrakcyjna, Adapter",
            "Singleton, Adapter, Obserwator"
    ]},
    {
        q: "W metodach lekkich wytwarzania oprogramowania",
        a: [
            "ważniejsze jest działające oprogramowanie niż obszerna dokumentacja",
            "nie uwzględnia się testowania oprogramowania",
            "ważna jest dokładna dokumentacja procesu",
            "nie uwzględnia się zagadnień związanych z jakością tworzonego kodu"
    ]},
    {
        q: "Programowanie regresyjne oznacza",
        a: [
            "ponowne wykonywanie utworzonych wcześniej testów",
            "wszystkie pozostałe odpowiedzi są prawidłowe",
            "przeprowadzanie inspekcji kodu",
            "przegląd wewnętrznej struktury programu"
    ]},
    {
        q: "+addEntry(): void jako opis operacji klasy oznacza że",
        a: [
            "metoda jest publiczna i nie zwraca żadnych wartości",
            "metoda jest prywatna i nie zwraca żadnych wartości",
            "jest to zapis konstruktora klasy",
            "jest to publiczny atrybut typu void"
    ]},
    {
        q: "W programowaniu ekstremalnym programowanie parami oznacza, że",
        a: [
            "jedna osoba jest programistą, a druga recenzentem kodu",
            "dwóch programistów pisze kod i wybierana jest lepsza wersja",
            "każdy programista ma pod opieką praktykanta",
            "jeden programista pisze kod a drugi tworzy dokumentację"
    ]},
    {
        q: "UML powstał",
        a: [
            "w wyniku połączenia metod OOAD, OOSE, OMT",
            "w latach 50-tych XX wieku",
            "jako wynik konkursu firmy IBM",
            "w wyniku praktycznej realizacji pracy naukowej G. Boocha"
    ]},
    {
        q: "Zaletą modelu opartego na prototypowaniu jest",
        a: [
            "możliwość szybkiej demonstracji pracującej wersji systemu",
            "możliwość implementacji systemu tylko w językach obiektowych",
            "długotrwała faza wstępnego projektu systemu",
            "długa przerwa w kontaktach z klientem"
    ]},
    {
        q: "W bibliotece CppUnit istnieje możliwość ustalenia stanu systemu przed wykonaniem każdego testu za pomocą",
        a: [
            "metody setUp()",
            "konstruktora obiektu typu testSuite()",
            "konstruktora obiektu typu testFixture()",
            "metody tearDown()"
    ]},
    {
        q: "Skrót UML w inżynierii oprogramowania oznacza",
        a: [
            "ujednolicony język modelowania",
            "ujednolicony model matematyczny",
            "uniwersalny model języka",
            "uniwersalny język matematyczny"
    ]},
    {
        q: "Makro CPPUNIT_ASSERT(a) z biblioteki CppUnit umożliwia",
        a: [
            "sprawdzenie czy wyrażnie a zwraca wartość prawda",
            "usunięcie z systemu obiektu a",
            "wywołanie destruktora obiektu a",
            "zarejestrowanie wyrażenia w grupie przypadków testowych"
    ]},
    {
        q: "Kolejność wywoływania komunikatów na diagramach sekwencji UML jest odczytywana dzięki",
        a: [
            "położeniu komunikatu, im wyzej tym wcześniej wywoływany jest komunikat",
            "liczbie przy nazwie komunikatu",
            "nie można zaznaczyć kolejności wywoływania komunikatów na tym typie diagramów",
            "położeniu komunikatu, im wyżej tym później wywoływany jest komunikat"
    ]}
];